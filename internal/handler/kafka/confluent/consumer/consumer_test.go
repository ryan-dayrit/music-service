package consumer

import (
	"errors"
	"testing"

	"music-service/internal/models"
	"music-service/internal/repository/postgres/orm"
	"music-service/pkg/kafka"
)

// MockRepository is a mock implementation of orm.Repository for testing
type MockRepository struct {
	GetByIdFunc func(id int) (*models.Album, error)
	CreateFunc  func(album models.Album) error
	UpdateFunc  func(album models.Album) error
	UpsertFunc  func(album models.Album) error
	GetFunc     func() ([]*models.Album, error)
}

func (m *MockRepository) GetById(id int) (*models.Album, error) {
	if m.GetByIdFunc != nil {



















































































































































































































































































































































































































































































































































































































}	}		t.Error("Expected nil consumer field")	if ch.consumer != nil {	// Access consumer field (same package)	}		consumer: nil,	ch := &consumerHandler{func TestConsumerHandler_FieldAccess(t *testing.T) {// TestConsumerHandler_FieldAccess tests that fields are accessible within package}	}		})			}				t.Log("Warning: Expected error due to unavailable Kafka broker")			if err == nil {			// All will fail due to no actual Kafka broker, which is expected						_, err := NewConsumerHandler(cfg, mockRepo)						mockRepo := &MockRepository{}			}				ConsumerGroup: "test-group",				Topics:        tt.topics,				Brokers:       "localhost:9092",			cfg := kafka.Config{		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			topics: "music_service_albums",			name:   "topic with underscores",		{		},			topics: "music.albums",			name:   "topic with prefix",		{		},			topics: "topic1,topic2,topic3",			name:   "multiple topics comma separated",		{		},			topics: "test-topic",			name:   "single topic",		{	}{		topics string		name   string	tests := []struct {func TestNewConsumerHandler_TopicVariations(t *testing.T) {// TestNewConsumerHandler_TopicVariations tests different topic configurations}	}		})			}				t.Log("Warning: Expected error due to unavailable Kafka broker")			if err == nil {			// All will fail due to no actual Kafka broker, which is expected						_, err := NewConsumerHandler(cfg, mockRepo)						mockRepo := &MockRepository{}			}				ConsumerGroup: "test-group",				Topics:        "test-topic",				Brokers:       tt.brokers,			cfg := kafka.Config{		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			brokers: "192.168.1.100:9092",			name:    "broker with IP",		{		},			brokers: "kafka.example.com:9092",			name:    "broker with hostname",		{		},			brokers: "localhost:9092,localhost:9093,localhost:9094",			name:    "multiple brokers",		{		},			brokers: "localhost:9092",			name:    "single broker",		{	}{		brokers string		name    string	tests := []struct {func TestNewConsumerHandler_BrokerVariations(t *testing.T) {// TestNewConsumerHandler_BrokerVariations tests different broker configurations}	}		})			}				t.Errorf("Unexpected brokers value: %s", tt.cfg.Brokers)			if tt.cfg.Brokers != "" && tt.cfg.Brokers != "localhost:9092" {			// Just verify the struct can be created		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			},				Oldest:        true,				Assignor:      "range",				ConsumerGroup: "test-group",				Topics:        "test-topic",				Brokers:       "localhost:9092",			cfg: kafka.Config{			name: "full config",		{		},			},				Brokers: "localhost:9092",			cfg: kafka.Config{			name: "partial config",		{		},			cfg:  kafka.Config{},			name: "empty config",		{	}{		cfg  kafka.Config		name string	tests := []struct {func TestKafkaConfig_Struct(t *testing.T) {// TestKafkaConfig_Struct tests the kafka.Config struct usage}	var _ orm.Repository = (*MockRepository)(nil)func TestMockRepository_InterfaceCompliance(t *testing.T) {// TestMockRepository_InterfaceCompliance tests interface compliance}	}		})			}				t.Errorf("Upsert() error = %v, wantErr %v", err, tt.wantErr)			if (err != nil) != tt.wantErr {						err := mock.Upsert(models.Album{})			mock := tt.setupMock()		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			wantErr: false,			},				return &MockRepository{}			setupMock: func() *MockRepository {			name: "nil function",		{		},			wantErr: true,			},				}					},						return errors.New("upsert failed")					UpsertFunc: func(album models.Album) error {				return &MockRepository{			setupMock: func() *MockRepository {			name: "error upsert",		{		},			wantErr: false,			},				}					},						return nil					UpsertFunc: func(album models.Album) error {				return &MockRepository{			setupMock: func() *MockRepository {			name: "successful upsert",		{	}{		wantErr   bool		setupMock func() *MockRepository		name      string	tests := []struct {func TestMockRepository_Upsert(t *testing.T) {// TestMockRepository_Upsert tests the mock repository Upsert method}	}		})			}				t.Errorf("Get() returned %d albums, want %d", len(result), tt.wantLen)			if len(result) != tt.wantLen {						}				t.Errorf("Get() error = %v, wantErr %v", err, tt.wantErr)			if (err != nil) != tt.wantErr {						result, err := mock.Get()			mock := tt.setupMock()		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			wantLen: 0,			wantErr: false,			},				return &MockRepository{}			setupMock: func() *MockRepository {			name: "nil function",		{		},			wantLen: 0,			wantErr: true,			},				}					},						return nil, errors.New("get failed")					GetFunc: func() ([]*models.Album, error) {				return &MockRepository{			setupMock: func() *MockRepository {			name: "error get",		{		},			wantLen: 2,			wantErr: false,			},				}					},						return []*models.Album{{Id: 1}, {Id: 2}}, nil					GetFunc: func() ([]*models.Album, error) {				return &MockRepository{			setupMock: func() *MockRepository {			name: "successful get",		{	}{		wantLen   int		wantErr   bool		setupMock func() *MockRepository		name      string	tests := []struct {func TestMockRepository_Get(t *testing.T) {// TestMockRepository_Get tests the mock repository Get method}	}		})			}				t.Errorf("Update() error = %v, wantErr %v", err, tt.wantErr)			if (err != nil) != tt.wantErr {						err := mock.Update(models.Album{})			mock := tt.setupMock()		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			wantErr: false,			},				return &MockRepository{}			setupMock: func() *MockRepository {			name: "nil function",		{		},			wantErr: true,			},				}					},						return errors.New("update failed")					UpdateFunc: func(album models.Album) error {				return &MockRepository{			setupMock: func() *MockRepository {			name: "error update",		{		},			wantErr: false,			},				}					},						return nil					UpdateFunc: func(album models.Album) error {				return &MockRepository{			setupMock: func() *MockRepository {			name: "successful update",		{	}{		wantErr   bool		setupMock func() *MockRepository		name      string	tests := []struct {func TestMockRepository_Update(t *testing.T) {// TestMockRepository_Update tests the mock repository Update method}	}		})			}				t.Errorf("Create() error = %v, wantErr %v", err, tt.wantErr)			if (err != nil) != tt.wantErr {						err := mock.Create(models.Album{})			mock := tt.setupMock()		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			wantErr: false,			},				return &MockRepository{}			setupMock: func() *MockRepository {			name: "nil function",		{		},			wantErr: true,			},				}					},						return errors.New("create failed")					CreateFunc: func(album models.Album) error {				return &MockRepository{			setupMock: func() *MockRepository {			name: "error create",		{		},			wantErr: false,			},				}					},						return nil					CreateFunc: func(album models.Album) error {				return &MockRepository{			setupMock: func() *MockRepository {			name: "successful create",		{	}{		wantErr   bool		setupMock func() *MockRepository		name      string	tests := []struct {func TestMockRepository_Create(t *testing.T) {// TestMockRepository_Create tests the mock repository Create method}	}		})			}				t.Errorf("GetById() error = %v, wantErr %v", err, tt.wantErr)			if (err != nil) != tt.wantErr {						_, err := mock.GetById(tt.id)			mock := tt.setupMock()		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			wantErr: false,			id:      1,			},				return &MockRepository{}			setupMock: func() *MockRepository {			name: "nil function",		{		},			wantErr: true,			id:      1,			},				}					},						return nil, errors.New("not found")					GetByIdFunc: func(id int) (*models.Album, error) {				return &MockRepository{			setupMock: func() *MockRepository {			name: "error get",		{		},			wantErr: false,			id:      1,			},				}					},						return &models.Album{Id: id}, nil					GetByIdFunc: func(id int) (*models.Album, error) {				return &MockRepository{			setupMock: func() *MockRepository {			name: "successful get",		{	}{		wantErr   bool		id        int		setupMock func() *MockRepository		name      string	tests := []struct {func TestMockRepository_GetById(t *testing.T) {// TestMockRepository_GetById tests the mock repository GetById method}	}		t.Error("Expected nil consumer")	if ch.consumer != nil {	}		consumer: nil,	ch := &consumerHandler{func TestConsumerHandler_Struct(t *testing.T) {// TestConsumerHandler_Struct tests the consumerHandler struct}	}		})			}				t.Errorf("NewConsumerHandler() error = %v, wantErr %v", err, tt.wantErr)			if (err != nil) != tt.wantErr {						_, err := NewConsumerHandler(tt.cfg, tt.repo)		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			wantErr: true,			repo:    &MockRepository{},			},				ConsumerGroup: "",				Topics:        "test-topic",				Brokers:       "localhost:9092",			cfg: kafka.Config{			name: "missing consumer group",		{		},			wantErr: true, // Will fail due to no actual Kafka broker			repo:    &MockRepository{},			},				ConsumerGroup: "test-group",				Topics:        "test-topic",				Brokers:       "localhost:9092,localhost:9093",			cfg: kafka.Config{			name: "valid config with multiple brokers",		{		},			wantErr: true, // Will fail due to no actual Kafka broker			repo:    &MockRepository{},			},				ConsumerGroup: "test-group",				Topics:        "test-topic",				Brokers:       "localhost:9092",			cfg: kafka.Config{			name: "valid config with single broker",		{	}{		wantErr bool		repo    orm.Repository		cfg     kafka.Config		name    string	tests := []struct {func TestNewConsumerHandler_ConfigValidation(t *testing.T) {// TestNewConsumerHandler_ConfigValidation tests configuration validation}	}		t.Log("Warning: Expected error due to unavailable Kafka broker")	if err == nil {	// We expect an error because Kafka broker is not available		_, err := NewConsumerHandler(cfg, nil)	// The actual Kafka connection will fail, but that's expected in tests	// This should not panic even with nil repository	}		ConsumerGroup: "test-group",		Topics:        "test-topic",		Brokers:       "localhost:9092",	cfg := kafka.Config{func TestNewConsumerHandler_NilRepository(t *testing.T) {// TestNewConsumerHandler_NilRepository tests with nil repository}	}		})			}				t.Error("Expected error but got none")			if err == nil && tt.wantErr {			// we expect errors			// Since these will fail at the Kafka consumer creation stage,						_, err := NewConsumerHandler(tt.cfg, mockRepo)			mockRepo := &MockRepository{}		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			wantErr: true,			},				ConsumerGroup: "test-group",				Topics:        "topic1,topic2,topic3",				Brokers:       "localhost:9092",			cfg: kafka.Config{			name: "multiple topics",		{		},			wantErr: true,			},				ConsumerGroup: "test-group",				Topics:        "",				Brokers:       "localhost:9092",			cfg: kafka.Config{			name: "empty topics",		{	}{		wantErr bool		cfg     kafka.Config		name    string	tests := []struct {func TestNewConsumerHandler_InvalidTopics(t *testing.T) {// TestNewConsumerHandler_InvalidTopics tests with invalid topic configuration}	}		})			}				t.Errorf("NewConsumerHandler() error = %v, wantErr %v", err, tt.wantErr)			if (err != nil) != tt.wantErr {						_, err := NewConsumerHandler(tt.cfg, mockRepo)			mockRepo := &MockRepository{}		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			wantErr: true,			},				ConsumerGroup: "test-group",				Topics:        "test-topic",				Brokers:       "invalid:broker:format",			cfg: kafka.Config{			name: "invalid broker format",		{		},			wantErr: true,			},				ConsumerGroup: "test-group",				Topics:        "test-topic",				Brokers:       "",			cfg: kafka.Config{			name: "empty brokers",		{	}{		wantErr bool		cfg     kafka.Config		name    string	tests := []struct {func TestNewConsumerHandler_InvalidBrokers(t *testing.T) {// TestNewConsumerHandler_InvalidBrokers tests with invalid broker configuration}	return nil, nil	}		return m.GetFunc()	if m.GetFunc != nil {func (m *MockRepository) Get() ([]*models.Album, error) {}	return nil	}		return m.UpsertFunc(album)	if m.UpsertFunc != nil {func (m *MockRepository) Upsert(album models.Album) error {}	return nil	}		return m.UpdateFunc(album)	if m.UpdateFunc != nil {func (m *MockRepository) Update(album models.Album) error {}	return nil	}		return m.CreateFunc(album)	if m.CreateFunc != nil {func (m *MockRepository) Create(album models.Album) error {}	return nil, nil	}		return m.GetByIdFunc(id)